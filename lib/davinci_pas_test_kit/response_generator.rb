module DaVinciPASTestKit
  module ResponseGenerator
    def mock_id_only_notification_bundle(submit_response, subscription_reference, subscription_topic)
      notification_timestamp = Time.now.utc
      mock_notification_bundle = build_mock_notification_bundle(notification_timestamp, subscription_reference,
                                                                subscription_topic, submit_response, 'id-only', nil)
      mock_notification_bundle.to_json
    end

    def mock_full_resource_notification_bundle(submit_response, subscription_reference, subscription_topic, decision)
      notification_timestamp = Time.now.utc
      mock_notification_bundle = build_mock_notification_bundle(notification_timestamp, subscription_reference,
                                                                subscription_topic, submit_response, 'full-resource',
                                                                decision)
      mock_notification_bundle.to_json
    end

    def mock_response_bundle(request_bundle, operation, decision, claim_response_uuid = nil)
      mocked_timestamp = Time.now.utc
      build_mock_response_bundle(request_bundle, operation, decision, mocked_timestamp, claim_response_uuid)&.to_json
    end

    # update things that tester cannot get right themselves
    # - timestamps on the Bundle and ClaimResponse (can't predict the processing time)
    # - reference to the submitted Claim (may not have control of created id). NOTE: this is likely
    #   incomplete - when the Claim is included, there are other things that
    #   need to be in the Bundle that may also not be controled
    def update_tester_provided_response(user_inputted_response, claim_full_url)
      response_bundle = FHIR.from_contents(user_inputted_response)
      return user_inputted_response unless response_bundle.present?

      now = Time.now.utc
      response_bundle.timestamp = now.iso8601 if response_bundle&.timestamp.present?
      claim_response_entry = response_bundle&.entry&.find { |e| e&.resource&.resourceType == 'ClaimResponse' }
      if claim_response_entry.present?
        claim_response_entry.resource.created = now.iso8601 if claim_response_entry.resource.created
        if claim_response_entry.resource.request.present? && claim_full_url.present?
          claim_response_entry.resource.request.reference = claim_full_url
        end
      end
      response_bundle.to_json
    end

    # update things that tester cannot get right themselves
    # - reference to the ClaimResponse in the case that it is generated by Inferno.
    #   If the tester provided the ClaimResponse, they are responsible for aligning
    #   the notification with it.
    # - notification timestamps
    def update_tester_provided_notification(user_inputted_notification, generated_claim_response_uuid)
      now = Time.now.utc

      notification_bundle = FHIR.from_contents(user_inputted_notification)
      subscription_status_entry = notification_bundle&.entry&.find { |e| e.resource&.resourceType == 'Parameters' }
      subscription_status_resource = subscription_status_entry&.resource
      event_parameter = subscription_status_resource&.parameter&.find { |p| p.name == 'notification-event' }

      if generated_claim_response_uuid.present?
        claim_response_full_url = "urn:uuid:#{generated_claim_response_uuid}"
        focus_part = event_parameter&.part&.find { |pt| pt.name == 'focus' }
        if focus_part.present?
          existing_claim_response_reference = focus_part.valueReference&.reference
          focus_part.valueReference.reference = claim_response_full_url
          update_tester_provided_notification_claim_response_entry(notification_bundle,
                                                                   generated_claim_response_uuid,
                                                                   claim_response_full_url,
                                                                   existing_claim_response_reference)

        end
      end

      timestamp_part = event_parameter&.part&.find { |pt| pt.name == 'timestamp' }
      timestamp_part.valueInstant = now.iso8601 if timestamp_part.present?
      notification_bundle.timestamp = now.iso8601 if notification_bundle.timestamp.present?

      notification_bundle.to_json
    end

    private

    # if there's a ClaimResponse entry (full-resource or id-only without the resource contents)
    # then update the fullUrl and id
    def update_tester_provided_notification_claim_response_entry(notification_bundle, claim_response_id,
                                                                 claim_response_full_url,
                                                                 existing_claim_response_reference)
      claim_response_entry = notification_bundle&.entry&.find { |e| e.resource&.resourceType == 'ClaimResponse' }
      if claim_response_entry.blank? && existing_claim_response_reference.present?
        claim_response_entry = notification_bundle&.entry&.find { |e| e.fullUrl == existing_claim_response_reference }
      end
      return unless claim_response_entry.present?

      claim_response_entry.fullUrl = claim_response_full_url
      return unless claim_response_entry.resource.present?

      claim_response_entry.resource.id = claim_response_id
    end

    def build_mock_notification_bundle(notification_timestamp, subscription_reference, subscription_topic,
                                       submit_response, type, decision)
      submit_bundle = FHIR.from_contents(submit_response)
      claim_response_full_url = claim_response_full_url_from_submit_response_bundle(submit_bundle)
      mock_notification_bundle = FHIR::Bundle.new(
        id: SecureRandom.uuid,
        timestamp: notification_timestamp.iso8601,
        type: 'history'
      )

      additional_context_references =
        if type == 'full-resource' && submit_bundle.present? && submit_bundle.is_a?(FHIR::Bundle)
          submit_bundle.entry.reject { |entry| entry.resource&.resourceType == 'ClaimResponse' }.map(&:fullUrl).compact
        else
          []
        end
      mock_notification_status = build_mock_notification_status(notification_timestamp, subscription_reference,
                                                                subscription_topic, claim_response_full_url,
                                                                additional_context_references)
      mock_notification_bundle.entry << build_mock_notification_status_entry(mock_notification_status,
                                                                             subscription_reference)
      if type == 'full-resource' && submit_bundle.present? && submit_bundle.is_a?(FHIR::Bundle)
        fhir_base_url = extract_fhir_base_url(subscription_reference)
        submit_bundle.entry.each do |entry|
          update_claim_response_decisions(entry.resource, decision) if entry.resource.resourceType == 'ClaimResponse'
          entry.request = FHIR::Bundle::Entry::Request.new(
            method: 'POST',
            url: "#{fhir_base_url}/#{entry.resource.resourceType}"
          )
          entry.response = FHIR::Bundle::Entry::Response.new(
            status: '201'
          )
          mock_notification_bundle.entry << entry
        end
      end

      mock_notification_bundle
    end

    def update_claim_response_decisions(claim_response, decision)
      claim_response&.item&.each do |item|
        item.adjudication.each do |adjudication|
          review_action_extension = adjudication.extension.find do |ext|
            ext.url == 'http://hl7.org/fhir/us/davinci-pas/StructureDefinition/extension-reviewAction'
          end
          review_code_extension = review_action_extension&.extension&.find do |ext|
            ext.url == 'http://hl7.org/fhir/us/davinci-pas/StructureDefinition/extension-reviewActionCode'
          end
          next unless review_code_extension.present?

          review_code_extension.valueCodeableConcept = FHIR::CodeableConcept.new(
            coding: [
              get_review_action_code(decision)
            ]
          )
        end
      end
    end

    def build_mock_response_bundle(request_bundle, operation, decision, timestamp, claim_response_uuid = nil)
      claim_entry = request_bundle&.entry&.find { |e| e&.resource&.resourceType == 'Claim' }
      claim_full_url = claim_entry&.fullUrl
      return nil if claim_entry.blank? || claim_full_url.blank?

      root_url = extract_fhir_base_url(claim_full_url)
      mocked_claim_response = build_mock_claim_response(claim_entry.resource, request_bundle, root_url, operation,
                                                        decision, timestamp, claim_response_uuid)
      build_mock_bundle(mocked_claim_response, request_bundle, root_url, operation, timestamp)
    end

    # Note that references from the claim to other resources in the bundle need to be changed to absolute URLs
    # if they are relative, because the ClaimResponse's fullUrl is a urn:uuid
    #
    # @private
    def build_mock_claim_response(claim, request_bundle, root_url, operation, decision, timestamp,
                                  claim_response_uuid = nil)
      claim_response_uuid = SecureRandom.uuid if claim_response_uuid.blank?
      return FHIR::ClaimResponse.new(id: claim_response_uuid) if claim.blank?

      FHIR::ClaimResponse.new(
        id: claim_response_uuid,
        meta: FHIR::Meta.new(profile: if operation == 'submit'
                                        'http://hl7.org/fhir/us/davinci-pas/StructureDefinition/profile-claimresponse'
                                      else
                                        'http://hl7.org/fhir/us/davinci-pas/StructureDefinition/profile-claiminquiryresponse'
                                      end),
        identifier: claim.identifier,
        type: claim.type,
        status: claim.status,
        use: claim.use,
        patient: absolute_reference(claim.patient, request_bundle.entry, root_url),
        created: timestamp.iso8601,
        insurer: absolute_reference(claim.insurer, request_bundle.entry, root_url),
        requestor: absolute_reference(claim.provider, request_bundle.entry, root_url),
        outcome: 'complete',
        item: claim.item.map do |item|
          FHIR::ClaimResponse::Item.new(
            extension: [
              FHIR::Extension.new(
                url: 'http://hl7.org/fhir/us/davinci-pas/StructureDefinition/extension-itemPreAuthIssueDate',
                valueDate: timestamp.strftime('%Y-%m-%d')
              ),
              FHIR::Extension.new(
                url: 'http://hl7.org/fhir/us/davinci-pas/StructureDefinition/extension-itemPreAuthPeriod',
                valuePeriod: FHIR::Period.new(start: timestamp.strftime('%Y-%m-%d'),
                                              end: (timestamp + 1.month).strftime('%Y-%m-%d'))
              )
            ],
            itemSequence: item.sequence,
            adjudication: [
              FHIR::ClaimResponse::Item::Adjudication.new(
                extension: [
                  FHIR::Extension.new(
                    url: 'http://hl7.org/fhir/us/davinci-pas/StructureDefinition/extension-reviewAction',
                    extension: [
                      FHIR::Extension.new(
                        url: 'http://hl7.org/fhir/us/davinci-pas/StructureDefinition/extension-reviewActionCode',
                        valueCodeableConcept: FHIR::CodeableConcept.new(
                          coding: [
                            get_review_action_code(decision)
                          ]
                        )
                      )
                    ]
                  )
                ],
                category: FHIR::CodeableConcept.new(
                  coding: [
                    FHIR::Coding.new(system: 'http://terminology.hl7.org/CodeSystem/adjudication', code: 'submitted')
                  ]
                )
              )
            ]
          )
        end
      )
    end

    def build_mock_bundle(claim_response, request_bundle, root_url, operation, timestamp)
      response_bundle = FHIR::Bundle.new(
        id: SecureRandom.uuid,
        meta: FHIR::Meta.new(profile: if operation == 'submit'
                                        'http://hl7.org/fhir/us/davinci-pas/StructureDefinition/profile-pas-response-bundle'
                                      else
                                        'http://hl7.org/fhir/us/davinci-pas/StructureDefinition/profile-pas-inquiry-response-bundle'
                                      end),
        timestamp: timestamp.iso8601,
        type: 'collection',
        entry: [
          FHIR::Bundle::Entry.new(fullUrl: "urn:uuid:#{claim_response.id}",
                                  resource: claim_response)
        ]
      )
      response_bundle.entry.concat(referenced_entities(claim_response, request_bundle.entry, root_url))
      response_bundle
    end

    def build_mock_notification_status_entry(status_parameters, subscription_reference)
      FHIR::Bundle::Entry.new(fullUrl: "urn:uuid:#{SecureRandom.uuid}",
                              resource: status_parameters,
                              request: FHIR::Bundle::Entry::Request.new(
                                method: 'GET',
                                url: "#{subscription_reference}/$status"
                              ),
                              response: FHIR::Bundle::Entry::Response.new(
                                status: '200'
                              ))
    end

    def build_mock_notification_status(timestamp, subscription_reference, subscription_topic, claim_response_reference,
                                       additional_context_references)
      status_parameters = FHIR::Parameters.new
      status_parameters.parameter << FHIR::Parameters::Parameter.new(
        name: 'subscription',
        valueReference: FHIR::Reference.new(
          reference: subscription_reference
        )
      )
      status_parameters.parameter << FHIR::Parameters::Parameter.new(
        name: 'topic',
        valueCanonical: subscription_topic
      )
      status_parameters.parameter << FHIR::Parameters::Parameter.new(
        name: 'status',
        valueCode: 'active'
      )
      status_parameters.parameter << FHIR::Parameters::Parameter.new(
        name: 'type',
        valueCode: 'event-notification'
      )
      status_parameters.parameter << FHIR::Parameters::Parameter.new(
        name: 'events-since-subscription-start',
        valueString: '1'
      )
      event = FHIR::Parameters::Parameter.new(
        name: 'notification-event'
      )
      status_parameters.parameter << event
      event.part << FHIR::Parameters::Parameter.new(
        name: 'event-number',
        valueString: '1'
      )
      event.part << FHIR::Parameters::Parameter.new(
        name: 'timestamp',
        valueInstant: timestamp.iso8601
      )
      event.part << FHIR::Parameters::Parameter.new(
        name: 'focus',
        valueReference: FHIR::Reference.new(
          reference: claim_response_reference
        )
      )
      additional_context_references&.each do |reference|
        event.part << FHIR::Parameters::Parameter.new(
          name: 'additional-context',
          valueReference: FHIR::Reference.new(
            reference:
          )
        )
      end
      status_parameters
    end

    def get_review_action_code(decision)
      case decision
      when :denial
        code = 'A3'
        display = 'Not Certified'
      when :pended
        code = 'A4'
        display = 'Pending'
      else # approval or no workflow
        code = 'A1'
        display = 'Certified in total'
      end
      FHIR::Coding.new(
        system: 'https://codesystem.x12.org/005010/306',
        code:,
        display:
      )
    end

    def absolute_reference(ref, entries, root_url)
      url = find_matching_entry(ref&.reference, entries, root_url)&.fullUrl
      ref.reference = url if url
      ref
    end

    def referenced_entities(resource, entries, root_url)
      matches = []
      attributes = resource&.source_hash&.keys
      attributes.each do |attr|
        value = resource.send(attr.to_sym)
        if value.is_a?(FHIR::Reference) && value.reference.present?
          match = find_matching_entry(value.reference, entries, root_url)
          if match.present? && matches.none?(match)
            value.reference = match.fullUrl
            matches.concat([match], referenced_entities(match.resource, entries, root_url))
          end
        elsif value.is_a?(Array) && value.all? { |elmt| elmt.is_a?(FHIR::Model) }
          value.each { |val| matches.concat(referenced_entities(val, entries, root_url)) }
        end
      end

      matches
    end

    def find_matching_entry(ref, entries, root_url = '')
      ref = "#{root_url}/#{ref}" if relative_reference?(ref) && root_url&.present?

      entries&.find { |entry| entry&.fullUrl == ref }
    end

    def relative_reference?(ref)
      ref&.count('/') == 1
    end

    # Drop the last two segments of a URL, i.e. the resource type and ID of a FHIR resource
    # e.g. http://example.org/fhir/Patient/123 -> http://example.org/fhir
    def extract_fhir_base_url(url)
      return unless url&.start_with?('http://', 'https://')

      # Drop everything after the second to last '/', ignoring a trailing slash
      url.sub(%r{/[^/]*/[^/]*(/)?\z}, '')
    end

    def claim_response_full_url_from_submit_response_bundle(submit_bundle)
      claim_response_entry = submit_bundle&.entry&.find { |e| e&.resource&.resourceType == 'ClaimResponse' }

      if claim_response_entry.present?
        return claim_response_entry.fullUrl unless claim_response_entry.fullUrl.blank?
        unless claim_response_entry.resource.blank? || claim_response_entry.resource.id.blank?
          return claim_response_entry.resource.id
        end
      end
      "urn:uuid:#{SecureRandom.uuid}"
    end
  end
end
